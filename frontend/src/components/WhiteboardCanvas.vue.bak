<template>
  <div class="whiteboard-container"
       @mousedown="handleCanvasMouseDown"
       @mousemove="handleCanvasMouseMove"
       @mouseup="handleCanvasMouseUp"
       @wheel="handleWheel"
       @contextmenu.prevent="handleRightClick"
       @click="closeContextMenu"
       :style="{ backgroundColor: whiteboardBackgroundColor }">
    <div class="toolbar" @mousedown.stop @mousemove.stop @mouseup.stop @click.stop @contextmenu.stop @wheel.stop>
      <div class="toolbar-left">
        <HamburgerMenu 
          :currentWhiteboardId="whiteboardId" 
          :initialBackgroundColor="whiteboardBackgroundColor"
          @update-background-color="handleBackgroundColorUpdate"
        />
        <button @click="addStickyNote" class="btn">Add Sticky Note</button>
        <button @click="toggleDrawMode" class="btn" :class="{ active: isDrawMode }">
          {{ isDrawMode ? 'Stop Drawing' : 'Draw' }}
        </button>
        <div v-if="isDrawMode" class="shape-toolbar">
        <button 
          @click="selectedShape = 'freehand'" 
          class="shape-btn" 
          :class="{ active: selectedShape === 'freehand' }"
          title="Freehand"
        >
          ‚úèÔ∏è
        </button>
        <button 
          @click="selectedShape = 'rectangle'" 
          class="shape-btn" 
          :class="{ active: selectedShape === 'rectangle' }"
          title="Rectangle"
        >
          ‚ñ≠
        </button>
        <button 
          @click="selectedShape = 'circle'" 
          class="shape-btn" 
          :class="{ active: selectedShape === 'circle' }"
          title="Circle"
        >
          ‚óã
        </button>
        <button 
          @click="selectedShape = 'triangle'" 
          class="shape-btn" 
          :class="{ active: selectedShape === 'triangle' }"
          title="Triangle"
        >
          ‚ñ≥
        </button>
        <button 
          @click="selectedShape = 'arrow'" 
          class="shape-btn" 
          :class="{ active: selectedShape === 'arrow' }"
          title="Arrow"
        >
          ‚Üí
        </button>
        <button 
          @click="selectedShape = 'line'" 
          class="shape-btn" 
          :class="{ active: selectedShape === 'line' }"
          title="Line"
        >
          ‚îÄ
        </button>
      </div>
      <select v-model="selectedColor" class="color-select">
        <option 
          v-for="color in standardColors" 
          :key="color.name" 
          :value="color.name"
        >
          {{ color.nickname || color.displayName }}
        </option>
        <optgroup v-if="customColors.length > 0" label="Custom Colors">
          <option 
            v-for="color in customColors" 
            :key="color.id" 
            :value="color.name"
          >
            {{ color.nickname || color.name }}
          </option>
        </optgroup>
      </select>
      <button @click="confirmDeleteSelectedGroup" class="btn btn-danger" v-if="selectedItems.length > 0">
        Delete Selected ({{ selectedItems.length }})
      </button>
      <button @click="confirmDeleteDrawing" class="btn btn-danger" v-if="selectedDrawing">
        Delete Drawing
      </button>
      <span v-if="!isDrawMode && drawings.length > 0" class="hint-text">
        üí° Click on drawings to select them
      </span>
      </div>
      
      <div class="toolbar-brand">
        <span class="brand-icon">ÔøΩ</span>
        <span class="brand-text">StickyTux</span>
      </div>
    </div>

    <!-- SVG for drawings (outside canvas-area so it covers the full viewport) -->
    <svg class="drawing-layer" 
         :style="svgStyle"
         @mousedown="handleSvgMouseDown"
         @mousemove="handleSvgMouseMove"
         @mouseup="handleSvgMouseUp">
      <g :transform="`translate(${panX} ${panY}) scale(${zoom})`">
        <path
          v-for="drawing in drawings"
          :key="drawing.id"
          :d="drawing.path_data"
          :stroke="drawing.color"
          :stroke-width="drawing.stroke_width"
          :class="{ 'selected-drawing': selectedDrawing === drawing.id }"
          fill="none"
          @click="selectDrawing(drawing.id, $event)"
          style="cursor: pointer;"
        />
        <path
          v-if="currentPath.length > 0"
          :d="currentPathData"
          :stroke="selectedColor"
          :stroke-width="2"
          fill="none"
        />
      </g>
    </svg>

    <div class="canvas-area"
         ref="canvas"
         :style="{ ...canvasStyle, backgroundColor: whiteboardBackgroundColor }">

      <!-- Sticky Notes -->
      <div
        v-for="note in stickyNotes"
        :key="note.id"
        class="sticky-note"
        :class="{ selected: selectedNotes.includes(note.id), editing: editingNote === note.id }"
        :style="getNoteStyle(note)"
        @mousedown.stop="handleNoteMouseDown($event, note)"
        @click.stop="selectNote(note.id, $event)"
        @dblclick.stop="startEditingNote(note.id)"
      >
        <div class="note-header">
          <button 
            @click.stop="toggleColorPicker(note.id)" 
            class="color-btn"
            title="Change color"
          >
            üé®
          </button>
          <button 
            @click.stop="toggleInsertMenu(note.id)" 
            class="insert-btn"
            title="Insert"
          >
            ‚ûï
          </button>
          <button @click.stop="confirmDeleteNote(note.id)" class="delete-btn">√ó</button>
        </div>
        
        <!-- Insert Menu -->
        <div 
          v-if="showInsertMenu === note.id" 
          class="insert-menu"
          @click.stop
        >
          <label class="insert-option" @click="handleInsertImage(note)">
            üñºÔ∏è Image
            <input 
              type="file" 
              accept="image/*"
              @change="handleImageUpload($event, note)"
              style="display: none;"
              ref="insertImageInput"
            />
          </label>
          <button class="insert-option" @click="insertCheckbox(note)">
            ‚òëÔ∏è Checkbox
          </button>
          <button class="insert-option" @click="toggleEmojiPicker(note.id)">
            üòä Emoji
          </button>
          <button class="insert-option" @click="insertHorizontalLine(note)">
            ‚ûñ Horizontal Line
          </button>
        </div>

        <!-- Emoji Picker -->
        <div 
          v-if="showEmojiPicker === note.id" 
          class="emoji-picker"
          @click.stop
        >
          <div class="emoji-categories">
            <button 
              v-for="cat in emojiCategories" 
              :key="cat.name"
              @click="selectedEmojiCategory = cat.name"
              class="category-btn"
              :class="{ active: selectedEmojiCategory === cat.name }"
              :title="cat.name"
            >
              {{ cat.icon }}
            </button>
          </div>
          <div class="emoji-grid-scrollable">
            <button
              v-for="emoji in currentCategoryEmojis"
              :key="emoji"
              class="emoji-btn"
              @click="insertEmoji(note, emoji)"
            >
              {{ emoji }}
            </button>
          </div>
        </div>
        
        <!-- Color Picker Menu -->
        <div 
          v-if="showColorPicker === note.id" 
          class="color-picker"
          @click.stop
        >
          <div class="color-grid">
            <button
              v-for="color in availableColors"
              :key="color"
              class="color-option"
              :style="{ backgroundColor: getNoteColor(color) }"
              @click="changeNoteColor(note.id, color)"
              :class="{ active: note.color === color }"
              :title="color"
            ></button>
            <button
              v-for="color in customColors"
              :key="color.id"
              class="color-option"
              :style="{ backgroundColor: color.hex_color }"
              @click="changeNoteColor(note.id, color.name)"
              :class="{ active: note.color === color.name }"
              :title="color.nickname || color.name"
            ></button>
          </div>
        </div>
        <div class="note-content" @dblclick.stop="startEditingNote(note.id)">
          <!-- Image carousel -->
          <div v-if="note.images && note.images.length > 0" class="image-carousel" @click.stop>
            <button 
              v-if="note.images.length > 1" 
              @click="prevImage(note.id)" 
              class="carousel-btn prev-btn"
              title="Previous image"
            >
              ‚Äπ
            </button>
            <div class="image-container">
              <img 
                :src="getCurrentImage(note).image" 
                class="note-image"
                @click.stop
              />
              <button 
                @click.stop="deleteCurrentImage(note)" 
                class="delete-image-btn"
                title="Delete this image"
              >
                √ó
              </button>
            </div>
            <button 
              v-if="note.images.length > 1" 
              @click="nextImage(note.id)" 
              class="carousel-btn next-btn"
              title="Next image"
            >
              ‚Ä∫
            </button>
            <div v-if="note.images.length > 1" class="image-counter">
              {{ (currentImageIndex[note.id] || 0) + 1 }} / {{ note.images.length }}
            </div>
          </div>
          <div 
            v-if="editingNote !== note.id" 
            class="note-text-display"
            @dblclick.stop="startEditingNote(note.id)"
            @click.stop="handleNoteTextClick($event, note)"
            @mousedown.stop
          >
            <template v-for="(line, index) in note.content.split('\n')" :key="index">
              <span v-if="line.trim().startsWith('‚òê') || line.trim().startsWith('‚òë')">
                <input 
                  type="checkbox" 
                  :checked="line.trim().startsWith('‚òë')"
                  @click.stop="toggleCheckbox(note, index)"
                  class="note-checkbox"
                />
                <span>{{ line.replace(/^[‚òê‚òë]\s*/, '') }}</span>
              </span>
              <span v-else>{{ line }}</span>
              <br v-if="index < note.content.split('\n').length - 1" />
            </template>
          </div>
          <textarea
            v-if="editingNote === note.id"
            v-model="note.content"
            @blur="stopEditingNote(note)"
            @click.stop
            @mousedown.stop
            placeholder="Double-click to edit..."
            ref="noteTextarea"
            class="editable"
          ></textarea>
          <input
            v-if="note.link"
            type="url"
            v-model="note.link"
            :readonly="editingNote !== note.id"
            @blur="stopEditingNote(note)"
            @click.stop
            @mousedown.stop
            placeholder="Enter URL..."
            class="link-input"
          />
        </div>
        <div class="resize-handle" @mousedown.stop="handleResizeMouseDown($event, note)"></div>
      </div>

      <!-- Text Elements -->
      <div
        v-for="textElement in textElements"
        :key="textElement.id"
        class="text-element"
        :class="{ selected: selectedTexts.includes(textElement.id), editing: editingText === textElement.id }"
        :style="getTextStyle(textElement)"
        @mousedown.stop="handleTextMouseDown($event, textElement)"
        @click.stop="selectText(textElement.id, $event)"
        @dblclick.stop="startEditingText(textElement.id)"
      >
        <textarea
          v-model="textElement.content"
          :readonly="editingText !== textElement.id"
          @blur="stopEditingText(textElement)"
          @click.stop
          @mousedown.stop
          placeholder="Double-click to edit..."
          class="text-input"
          :class="{ editable: editingText === textElement.id }"
          :style="{ fontSize: textElement.fontSize + 'px', color: textElement.color }"
        ></textarea>
        <button 
          @click.stop="toggleTextColorPicker(textElement.id)" 
          class="text-color-btn"
          title="Change text color"
        >
          üé®
        </button>
        <div 
          v-if="textColorPickerVisible === textElement.id" 
          class="text-color-picker"
          @click.stop
        >
          <input 
            type="color" 
            v-model="textElement.color" 
            @change="saveTextElementsToLocalStorage()"
            class="text-color-input"
          />
          <span class="text-color-value">{{ textElement.color }}</span>
        </div>
        <button @click.stop="confirmDeleteText(textElement.id)" class="text-delete-btn">√ó</button>
        <div class="text-resize-handle" @mousedown.stop="handleTextResizeMouseDown($event, textElement)"></div>
      </div>
    </div>

    <!-- Delete Confirmation Dialog (outside canvas-area so it's not affected by transform) -->
    <div v-if="deleteModal.visible" class="modal-overlay" @click="cancelDelete">
      <div class="modal" @click.stop>
        <h3>{{ deleteModal.title }}</h3>
        <p>{{ deleteModal.message }}</p>
        <div class="modal-actions">
          <button @click="confirmDelete" class="btn btn-danger">Delete</button>
          <button @click="cancelDelete" class="btn">Cancel</button>
        </div>
      </div>
    </div>

    <!-- Context Menu (outside canvas-area so it's not affected by transform) -->
    <div
      v-if="contextMenu.visible"
      class="context-menu"
      :style="{ 
        left: contextMenu.screenX + 'px', 
        top: contextMenu.screenY + 'px',
        transform: `scale(${contextMenu.scale})`,
        transformOrigin: 'top left'
      }"
    >
      <div @click="addStickyNoteAt(contextMenu.canvasX, contextMenu.canvasY)">Add Sticky Note</div>
      <div @click="addLinkNote(contextMenu.canvasX, contextMenu.canvasY)">Add Note with Link</div>
      <div @click="addTextAt(contextMenu.canvasX, contextMenu.canvasY)">Add Text</div>
    </div>
  </div>
</template>

<script>
import { ref, computed, onMounted, onUnmounted, nextTick, watch } from 'vue'
import { useRoute } from 'vue-router'
import api from '../services/api'
import HamburgerMenu from './HamburgerMenu.vue'

export default {
  name: 'WhiteboardCanvas',
  components: {
    HamburgerMenu,
  },
  setup() {
    const route = useRoute()
    const whiteboardId = computed(() => route.params.id)

    // Large whiteboard dimensions - much bigger than viewport for infinite feel
    const WHITEBOARD_WIDTH = ref(20000)  // Very large working area
    const WHITEBOARD_HEIGHT = ref(15000)
    
    // Canvas state
    const canvas = ref(null)
    const zoom = ref(1)
    const panX = ref(0)
    const panY = ref(0)
    const isPanning = ref(false)
    const panStartX = ref(0)
    const panStartY = ref(0)
    
    // Whiteboard settings
    const whiteboardBackgroundColor = ref('#ffffff')

    // Sticky notes
  const stickyNotes = ref([])
  const selectedNotes = ref([])
  // Mixed-type selection (stores objects like { type: 'note'|'text'|'drawing', id })
  const selectedItems = ref([])
    const selectedColor = ref('yellow')
    const draggedNote = ref(null)
    const dragOffset = ref({ x: 0, y: 0 })
    const resizingNote = ref(null)
    const editingNote = ref(null)
    
    // Color picker
    const showColorPicker = ref(null)
    const availableColors = ['yellow', 'pink', 'blue', 'green', 'orange', 'purple']
    const standardColors = ref([
      { name: 'yellow', displayName: 'Yellow', nickname: '' },
      { name: 'pink', displayName: 'Pink', nickname: '' },
      { name: 'blue', displayName: 'Blue', nickname: '' },
      { name: 'green', displayName: 'Green', nickname: '' },
      { name: 'orange', displayName: 'Orange', nickname: '' },
      { name: 'purple', displayName: 'Purple', nickname: '' }
    ])
    const customColors = ref([])
    
    // Insert menu
    const showInsertMenu = ref(null)
    const showEmojiPicker = ref(null)
    const selectedEmojiCategory = ref('Smileys')
    
    const emojiCategories = [
      { 
        name: 'Smileys', 
        icon: 'üòÄ',
        emojis: ['ÔøΩ', 'ÔøΩüòÉ', 'üòÑ', 'üòÅ', 'üòÜ', 'üòÖ', 'ü§£', 'üòÇ', 'üôÇ', 'üôÉ', 'üòâ', 'üòä', 'üòá', 'ü•∞', 'üòç', 'ü§©', 'üòò', 'üòó', 'üòö', 'üòô', 'ü•≤', 'üòã', 'üòõ', 'üòú', 'ü§™', 'üòù', 'ü§ë', 'ü§ó', 'ü§≠', 'ü§´', 'ü§î', 'ü§ê', 'ü§®', 'üòê', 'üòë', 'üò∂', 'üòè', 'üòí', 'üôÑ', 'üò¨', 'ü§•', 'üòå', 'üòî', 'üò™', 'ü§§', 'üò¥', 'üò∑', 'ü§í', 'ü§ï', 'ü§¢', 'ü§Æ', 'ü§ß', 'ü•µ', 'ü•∂', 'üòé', 'ü§ì', 'üßê', 'üòï', 'üòü', 'üôÅ', '‚òπÔ∏è', 'üòÆ', 'üòØ', 'üò≤', 'üò≥', 'ü•∫', 'üò¶', 'üòß', 'üò®', 'üò∞', 'üò•', 'üò¢', 'üò≠', 'üò±', 'üòñ', 'üò£', 'üòû', 'üòì', 'üò©', 'üò´', 'ü•±', 'üò§', 'üò°', 'üò†', 'ü§¨', 'üòà', 'üëø', 'üíÄ', '‚ò†Ô∏è']
      },
      { 
        name: 'Hearts', 
        icon: '‚ù§Ô∏è',
        emojis: ['‚ù§Ô∏è', 'üß°', 'üíõ', 'üíö', 'üíô', 'üíú', 'üñ§', 'ü§ç', 'ü§é', 'üíî', '‚ù§Ô∏è‚Äçüî•', '‚ù§Ô∏è‚Äçü©π', '‚ù£Ô∏è', 'üíï', 'ÔøΩ', 'üíì', 'üíó', 'ÔøΩüíñ', 'üíò', 'üíù', 'üíü']
      },
      { 
        name: 'Gestures', 
        icon: 'ÔøΩ',
        emojis: ['üëã', 'ü§ö', 'ÔøΩÔ∏è', '‚úã', 'ÔøΩ', 'ÔøΩ', 'ü§å', 'ü§è', '‚úåÔ∏è', 'ü§û', 'ÔøΩ', 'ü§ò', 'ü§ô', 'üëà', 'üëâ', 'üëÜ', 'ÔøΩ', 'üëá', '‚òùÔ∏è', 'ÔøΩüëç', 'üëé', '‚úä', 'üëä', 'ü§õ', 'ü§ú', 'üëè', 'üôå', 'üëê', 'ü§≤', 'ü§ù', 'üôè', '‚úçÔ∏è', 'üíÖ', 'ü§≥', 'üí™', 'ü¶æ', 'ü¶ø', 'ü¶µ', 'ü¶∂']
      },
      { 
        name: 'Symbols', 
        icon: '‚úÖ',
        emojis: ['‚úÖ', '‚ùå', '‚≠ê', 'ÔøΩ', '‚ú®', '‚ö°', 'üî•', 'üí•', 'üí´', 'üí¢', 'üí¶', 'üí®', 'üï≥Ô∏è', 'üí¨', 'üëÅÔ∏è‚Äçüó®Ô∏è', 'üó®Ô∏è', 'ÔøΩÔ∏è', 'üí≠', 'üí§', 'ÔøΩüí°', 'ÔøΩ', 'üîï', 'üéµ', 'ÔøΩ', 'ÔøΩüéØ', 'üé≤', 'üé∞', 'üé≥', 'üéÆ', 'üé™', 'üé≠', 'üé®', 'üé¨', 'üé§', 'üéß', 'üéº', 'üéπ', 'ü•Å', 'üé∑', 'üé∫', 'üé∏', 'ü™ï', 'üéª']
      },
      { 
        name: 'Objects', 
        icon: 'üìå',
        emojis: ['ÔøΩ', 'ÔøΩüìç', 'üö©', 'ÔøΩ', 'üè≥Ô∏è', 'üè¥', 'üè≥Ô∏è‚Äçüåà', 'üè≥Ô∏è‚Äç‚ößÔ∏è', 'üè¥‚Äç‚ò†Ô∏è', 'üìÅ', 'üìÇ', 'üóÇÔ∏è', 'üóÉÔ∏è', 'üìã', 'üìä', 'üìà', 'üìâ', 'üìá', 'üìÖ', 'üìÜ', 'üóìÔ∏è', 'üìé', 'üñáÔ∏è', 'üìê', 'üìè', 'üßÆ', 'üìå', 'üìç', '‚úÇÔ∏è', 'üñäÔ∏è', 'üñãÔ∏è', '‚úíÔ∏è', 'üñåÔ∏è', 'üñçÔ∏è', 'üìù', 'üíº', 'üìÅ', 'üìÇ', 'üóÇÔ∏è', 'üìÖ', 'üìÜ', 'üóíÔ∏è', 'üóìÔ∏è']
      },
      { 
        name: 'Achievements', 
        icon: 'ÔøΩüèÜ',
        emojis: ['üèÜ', 'ü•á', 'ü•à', 'ü•â', 'üèÖ', 'üéñÔ∏è', 'üéóÔ∏è', 'ü•ã', 'üé™', 'üé≠', 'üé®', 'üé¨', 'üé§', 'üéß', 'üéº', 'üéπ', 'ü•Å', 'üé∑', 'üé∫', 'üé∏', 'ü™ï', 'üéª', 'üé≤', 'üéØ', 'üé≥', 'üéÆ', 'üé∞']
      }
    ]

    const currentCategoryEmojis = computed(() => {
      const category = emojiCategories.find(c => c.name === selectedEmojiCategory.value)
      return category ? category.emojis : emojiCategories[0].emojis
    })
    
    // Image carousel
    const currentImageIndex = ref({})
    
    // Delete confirmation modal
    const deleteModal = ref({
      visible: false,
      title: '',
      message: '',
      onConfirm: null,
      data: null
    })

    // Text color picker
    const textColorPickerVisible = ref(null)

    // Drawing
    const isDrawMode = ref(false)
    const selectedShape = ref('freehand')
    const drawings = ref([])
    const currentPath = ref([])
    const isDrawing = ref(false)
    const selectedDrawing = ref(null)
    const shapeStartPoint = ref(null)

    // Text elements
    const textElements = ref([])
    const selectedTexts = ref([])
    const draggedText = ref(null)
    const editingText = ref(null)
    const resizingText = ref(null)
    const textInitialSize = ref({ width: 0, height: 0, fontSize: 0 })

    // Context menu
    const contextMenu = ref({
      visible: false,
      x: 0,
      y: 0,
    })

    // WebSocket
    let ws = null

    const canvasStyle = computed(() => ({
      transform: `translate(${panX.value}px, ${panY.value}px) scale(${zoom.value})`,
      transformOrigin: '0 0',
      cursor: isPanning.value ? 'grabbing' : 'default',
    }))

    const svgStyle = computed(() => ({
      width: '100vw',
      height: 'calc(100vh - 60px)',
      position: 'fixed',
      top: '60px',
      left: 0,
      pointerEvents: isDrawMode.value ? 'auto' : 'none',
      zIndex: 1001,
    }))

    // Calculate minimum zoom to fit the large whiteboard in viewport
    const minZoom = computed(() => {
      if (!canvas.value) return 0.05
      const canvasRect = canvas.value.getBoundingClientRect()
      const scaleX = canvasRect.width / WHITEBOARD_WIDTH.value
      const scaleY = canvasRect.height / WHITEBOARD_HEIGHT.value
      // Use the smaller scale to ensure the entire whiteboard fits
      return Math.min(scaleX, scaleY)
    })

    const currentPathData = computed(() => {
      if (currentPath.value.length === 0) return ''
      return (
        'M ' +
        currentPath.value
          .map((point) => `${point.x},${point.y}`)
          .join(' L ')
      )
    })

    // Generate consistent random values for a note based on its ID
    function getRandomForNote(noteId, type) {
      // Simple hash function to generate consistent random values
      let hash = 0
      const seed = noteId.toString() + type
      for (let i = 0; i < seed.length; i++) {
        const char = seed.charCodeAt(i)
        hash = ((hash << 5) - hash) + char
        hash = hash & hash // Convert to 32-bit integer
      }
      return Math.abs(hash % 1000) / 1000 // Return value between 0 and 1
    }

    function getNoteStyle(note) {
      // Generate random rotation between -3 and 3 degrees
      const rotation = (getRandomForNote(note.id, 'rotation') - 0.5) * 6
      
      return {
        left: note.x + 'px',
        top: note.y + 'px',
        width: note.width + 'px',
        height: note.height + 'px',
        zIndex: note.z_index,
        transform: `rotate(${rotation}deg)`,
        transformOrigin: 'center center',
        backgroundColor: getNoteColor(note.color),
        '--rotation': `${rotation}deg`,
      }
    }

    function getNoteColor(color) {
      const colors = {
        yellow: '#feff7c',
        pink: '#ffb3e6',
        blue: '#7dd3fc',
        green: '#bbf7d0',
        orange: '#fed7aa',
        purple: '#ddd6fe',
      }
      
      // Check if it's a custom color
      const customColor = customColors.value.find(c => c.name === color)
      if (customColor) {
        return customColor.hex_color
      }
      
      return colors[color] || colors.yellow
    }

    // Keep per-type selection arrays in sync with mixed `selectedItems`
    function syncSelectedArraysFromItems() {
      selectedNotes.value = selectedItems.value.filter(i => i.type === 'note').map(i => i.id)
      selectedTexts.value = selectedItems.value.filter(i => i.type === 'text').map(i => i.id)
      const drawingItem = selectedItems.value.find(i => i.type === 'drawing')
      selectedDrawing.value = drawingItem ? drawingItem.id : null
    }

    // Allow free positioning anywhere on the infinite whiteboard
    function constrainToWhiteboard(x, y, width = 200, height = 200) {
      // No constraints - infinite whiteboard space
      return {
        x: x,
        y: y
      }
    }

    async function loadWhiteboard() {
      try {
        const response = await api.getWhiteboard(whiteboardId.value)
        stickyNotes.value = response.data.sticky_notes || []
        
        // Load whiteboard background color
        whiteboardBackgroundColor.value = response.data.background_color || '#ffffff'
        
        // Ensure all image URLs are absolute
        stickyNotes.value.forEach(note => {
          if (note.images) {
            note.images.forEach(img => {
              if (img.image && !img.image.startsWith('http')) {
                img.image = `http://localhost:8000${img.image}`
              }
            })
          }
        })
        
        drawings.value = response.data.drawings || []
      } catch (error) {
        console.error('Error loading whiteboard:', error)
      }
    }

    // View settings persistence
    let saveViewSettingsTimeout = null
    
    async function loadViewSettings() {
      try {
        const response = await api.getViewSettings(whiteboardId.value)
        if (response.data) {
          zoom.value = response.data.zoom || 1.0
          panX.value = response.data.pan_x || 0.0
          panY.value = response.data.pan_y || 0.0
        }
      } catch (error) {
        console.error('Error loading view settings:', error)
      }
    }
    
    function saveViewSettings() {
      // Debounce the save to avoid too many API calls
      if (saveViewSettingsTimeout) {
        clearTimeout(saveViewSettingsTimeout)
      }
      
      saveViewSettingsTimeout = setTimeout(async () => {
        try {
          await api.saveViewSettings(whiteboardId.value, zoom.value, panX.value, panY.value)
        } catch (error) {
          console.error('Error saving view settings:', error)
        }
      }, 1000) // Save after 1 second of inactivity
    }

    async function addStickyNote() {
      try {
        // Place note around the center (0,0) with some random offset
        const offsetX = (Math.random() - 0.5) * 400 // Random position within 400px of center
        const offsetY = (Math.random() - 0.5) * 400
        
        const constrainedPos = constrainToWhiteboard(offsetX, offsetY, 200, 200)
        const response = await api.createStickyNote({
          whiteboard: whiteboardId.value,
          content: '',
          color: selectedColor.value,
          x: constrainedPos.x,
          y: constrainedPos.y,
          width: 200,
          height: 200,
          z_index: stickyNotes.value.length,
        })
        stickyNotes.value.push(response.data)
        broadcastUpdate({ type: 'note_added', note: response.data })
      } catch (error) {
        console.error('Error adding sticky note:', error)
      }
    }

    async function addStickyNoteAt(x, y) {
      try {
        console.log('Creating sticky note at:', {
          canvasX: x,
          canvasY: y,
          contextMenuScreenX: contextMenu.value.screenX,
          contextMenuScreenY: contextMenu.value.screenY,
          // Calculate where this will appear on screen
          expectedScreenX: (panX.value + x) * zoom.value,
          expectedScreenY: (panY.value + y) * zoom.value + 60,
          panX: panX.value,
          panY: panY.value,
          zoom: zoom.value
        })
        
        // x and y are already canvas coordinates from the context menu
        const response = await api.createStickyNote({
          whiteboard: whiteboardId.value,
          content: '',
          color: selectedColor.value,
          x: x,
          y: y,
          width: 200,
          height: 200,
          z_index: stickyNotes.value.length,
        })
        
        console.log('Sticky note created with data:', {
          id: response.data.id,
          x: response.data.x,
          y: response.data.y,
          // Where it should appear
          shouldAppearAtScreenX: (panX.value + response.data.x) * zoom.value,
          shouldAppearAtScreenY: (panY.value + response.data.y) * zoom.value + 60
        })
        
        stickyNotes.value.push(response.data)
        broadcastUpdate({ type: 'note_added', note: response.data })
      } catch (error) {
        console.error('Error adding sticky note:', error)
      }
      contextMenu.value.visible = false
    }

    async function addLinkNote(x, y) {
      try {
        // x and y are already canvas coordinates from the context menu
        const response = await api.createStickyNote({
          whiteboard: whiteboardId.value,
          content: '',
          link: 'https://',
          color: selectedColor.value,
          x: x,
          y: y,
          width: 200,
          height: 200,
          z_index: stickyNotes.value.length,
        })
        stickyNotes.value.push(response.data)
        broadcastUpdate({ type: 'note_added', note: response.data })
      } catch (error) {
        console.error('Error adding sticky note:', error)
      }
      contextMenu.value.visible = false
    }

    async function updateNote(note) {
      try {
        await api.updateStickyNote(note.id, note)
        broadcastUpdate({ type: 'note_updated', note })
      } catch (error) {
        console.error('Error updating sticky note:', error)
      }
    }

    function startEditingNote(noteId) {
      editingNote.value = noteId
      // Focus the textarea after Vue updates the DOM
      nextTick(() => {
        const textareas = document.querySelectorAll('.sticky-note.editing textarea')
        if (textareas.length > 0) {
          textareas[0].focus()
        }
      })
    }

    function stopEditingNote(note) {
      editingNote.value = null
      updateNote(note)
    }

    function startEditingText(textId) {
      editingText.value = textId
      nextTick(() => {
        const textareas = document.querySelectorAll('.text-element.editing textarea')
        if (textareas.length > 0) {
          textareas[0].focus()
        }
      })
    }

    function stopEditingText(textElement) {
      editingText.value = null
      updateText(textElement)
    }

    async function deleteNote(noteId) {
      try {
        await api.deleteStickyNote(noteId)
        stickyNotes.value = stickyNotes.value.filter((n) => n.id !== noteId)
        selectedNotes.value = selectedNotes.value.filter((id) => id !== noteId)
        broadcastUpdate({ type: 'note_deleted', noteId })
      } catch (error) {
        console.error('Error deleting sticky note:', error)
      }
    }

    async function deleteSelected() {
      for (const noteId of selectedNotes.value) {
        await deleteNote(noteId)
      }
      selectedNotes.value = []
    }

    async function deleteSelectedGroup() {
      // Snapshot to avoid mutation during iteration
      const items = [...selectedItems.value]

      for (const item of items) {
        try {
          if (item.type === 'note') {
            await deleteNote(item.id)
          } else if (item.type === 'text') {
            deleteText(item.id)
          } else if (item.type === 'drawing') {
            await api.deleteDrawing(item.id)
            drawings.value = drawings.value.filter(d => d.id !== item.id)
            if (selectedDrawing.value === item.id) selectedDrawing.value = null
          }
        } catch (error) {
          console.error('Error deleting selected item', item, error)
        }
      }

      // Clear selections
      selectedItems.value = []
      selectedNotes.value = []
      selectedTexts.value = []
      selectedDrawing.value = null
    }

    function showDeleteModal(title, message, onConfirm, data = null) {
      deleteModal.value = {
        visible: true,
        title,
        message,
        onConfirm,
        data
      }
    }

    function confirmDeleteNote(noteId) {
      showDeleteModal(
        'Delete Note',
        'Are you sure you want to delete this sticky note?',
        async () => {
          await deleteNote(noteId)
        }
      )
    }

    function confirmDeleteSelectedGroup() {
      const count = selectedItems.value.length
      showDeleteModal(
        'Delete Selected Items',
        `Are you sure you want to delete ${count} selected item${count > 1 ? 's' : ''}?`,
        async () => {
          await deleteSelectedGroup()
        }
      )
    }

    function cancelDelete() {
      deleteModal.value.visible = false
      deleteModal.value.onConfirm = null
      deleteModal.value.data = null
    }

    async function confirmDelete() {
      if (deleteModal.value.onConfirm) {
        await deleteModal.value.onConfirm()
        cancelDelete()
      }
    }

    function toggleColorPicker(noteId) {
      showColorPicker.value = showColorPicker.value === noteId ? null : noteId
    }

    async function changeNoteColor(noteId, color) {
      const note = stickyNotes.value.find(n => n.id === noteId)
      if (note) {
        note.color = color
        await updateNote(note)
        showColorPicker.value = null
      }
    }

    async function loadCustomColors() {
      try {
        const response = await api.getCustomColors()
        customColors.value = response.data
      } catch (error) {
        console.error('Error loading custom colors:', error)
      }
    }

    function loadStandardColorNicknames() {
      const saved = localStorage.getItem('standardColorNicknames')
      if (saved) {
        try {
          const nicknames = JSON.parse(saved)
          standardColors.value.forEach(color => {
            if (nicknames[color.name]) {
              color.nickname = nicknames[color.name]
            }
          })
        } catch (error) {
          console.error('Error loading standard color nicknames:', error)
        }
      }
    }

    // Insert menu functions
    function toggleInsertMenu(noteId) {
      showInsertMenu.value = showInsertMenu.value === noteId ? null : noteId
      showEmojiPicker.value = null // Close emoji picker when opening insert menu
    }

    function toggleEmojiPicker(noteId) {
      showEmojiPicker.value = showEmojiPicker.value === noteId ? null : noteId
    }

    function handleInsertImage(note) {
      // Trigger file input click
      showInsertMenu.value = null
      // The actual file input is in the template and will handle the upload
    }

    function insertCheckbox(note) {
      const checkbox = '\n‚òê '
      if (note.content) {
        note.content += checkbox
      } else {
        note.content = checkbox
      }
      updateNote(note)
      showInsertMenu.value = null
    }

    function insertEmoji(note, emoji) {
      if (note.content) {
        note.content += emoji
      } else {
        note.content = emoji
      }
      updateNote(note)
      showEmojiPicker.value = null
      showInsertMenu.value = null
    }

    function insertHorizontalLine(note) {
      const line = '\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n'
      if (note.content) {
        note.content += line
      } else {
        note.content = line
      }
      updateNote(note)
      showInsertMenu.value = null
    }

    function toggleCheckbox(note, lineIndex) {
      const lines = note.content.split('\n')
      if (lines[lineIndex]) {
        if (lines[lineIndex].trim().startsWith('‚òê')) {
          lines[lineIndex] = lines[lineIndex].replace('‚òê', '‚òë')
        } else if (lines[lineIndex].trim().startsWith('‚òë')) {
          lines[lineIndex] = lines[lineIndex].replace('‚òë', '‚òê')
        }
        note.content = lines.join('\n')
        updateNote(note)
      }
    }

    function handleNoteTextClick(event, note) {
      // This prevents starting a drag when clicking on text
      event.stopPropagation()
    }

    async function handleImageUpload(event, note) {
      const file = event.target.files[0]
      if (file) {
        try {
          const response = await api.addImageToNote(note.id, file)
          
          // Add the new image to the note's images array
          if (!note.images) {
            note.images = []
          }
          
          // Ensure the image URL is absolute
          const imageData = response.data
          if (imageData.image && !imageData.image.startsWith('http')) {
            imageData.image = `http://localhost:8000${imageData.image}`
          }
          
          note.images.push(imageData)
          
          // Set the current image index to the newly added image
          currentImageIndex.value[note.id] = note.images.length - 1
          
          broadcastUpdate({ type: 'note_updated', note })
        } catch (error) {
          console.error('Error uploading image:', error)
          console.error('Error response:', error.response?.data)
        }
      }
      // Reset the input
      event.target.value = ''
    }

    function getCurrentImage(note) {
      if (!note.images || note.images.length === 0) return null
      const index = currentImageIndex.value[note.id] || 0
      return note.images[index] || note.images[0]
    }

    function nextImage(noteId) {
      const note = stickyNotes.value.find(n => n.id === noteId)
      if (!note || !note.images || note.images.length === 0) return
      
      const currentIndex = currentImageIndex.value[noteId] || 0
      currentImageIndex.value[noteId] = (currentIndex + 1) % note.images.length
    }

    function prevImage(noteId) {
      const note = stickyNotes.value.find(n => n.id === noteId)
      if (!note || !note.images || note.images.length === 0) return
      
      const currentIndex = currentImageIndex.value[noteId] || 0
      currentImageIndex.value[noteId] = currentIndex === 0 ? note.images.length - 1 : currentIndex - 1
    }

    async function deleteCurrentImage(note) {
      console.log('deleteCurrentImage called with:', { 
        noteId: note.id, 
        hasImages: !!note.images, 
        imageCount: note.images?.length,
        currentIndex: currentImageIndex.value[note.id]
      })
      
      if (!note.images || note.images.length === 0) {
        console.log('No images to delete')
        return
      }
      
      const currentIndex = currentImageIndex.value[note.id] || 0
      const imageToDelete = note.images[currentIndex]
      
      console.log('Image to delete:', imageToDelete)
      
      showDeleteModal(
        'Delete Image',
        'Are you sure you want to delete this image?',
        async () => {
          try {
            console.log('Calling API to delete image ID:', imageToDelete.id)
            await api.deleteNoteImage(imageToDelete.id)
            
            // Remove the image from the array
            note.images.splice(currentIndex, 1)
            console.log('Image removed from array, remaining images:', note.images.length)
            
            // Adjust the current index
            if (note.images.length === 0) {
              delete currentImageIndex.value[note.id]
            } else if (currentIndex >= note.images.length) {
              currentImageIndex.value[note.id] = note.images.length - 1
            }
            
            broadcastUpdate({ type: 'note_updated', note })
            console.log('Image delete complete')
          } catch (error) {
            console.error('Error deleting image:', error)
            console.error('Error details:', error.response?.data)
          }
        }
      )
    }

    // Text element functions
    async function addTextAt(x, y) {
      try {
        // x and y are already canvas coordinates from the context menu
        const textElement = {
          id: Date.now(), // Temporary ID
          content: 'New Text',
          x: x,
          y: y,
          width: 200,
          height: 100,
          fontSize: 16,
          color: '#333',
          fontFamily: 'Arial, sans-serif'
        }
        
        textElements.value.push(textElement)
        saveTextElementsToLocalStorage()
        contextMenu.value.visible = false
      } catch (error) {
        console.error('Error adding text:', error)
      }
    }

    function getTextStyle(textElement) {
      const isDragging = draggedText.value && draggedText.value.id === textElement.id
      
      // Convert hex color to rgba with opacity
      const hexToRgba = (hex, opacity) => {
        const r = parseInt(hex.slice(1, 3), 16)
        const g = parseInt(hex.slice(3, 5), 16)
        const b = parseInt(hex.slice(5, 7), 16)
        return `rgba(${r}, ${g}, ${b}, ${opacity})`
      }
      
      const bgColor = hexToRgba(whiteboardBackgroundColor.value, 0.9)
      
      return {
        left: textElement.x + 'px',
        top: textElement.y + 'px',
        width: textElement.width + 'px',
        height: textElement.height + 'px',
        backgroundColor: bgColor,
        zIndex: 1000,
      }
    }

    function selectText(textId, event) {
      if (event.ctrlKey || event.metaKey) {
        const exists = selectedItems.value.find(i => i.type === 'text' && i.id === textId)
        if (exists) {
          selectedItems.value = selectedItems.value.filter(i => !(i.type === 'text' && i.id === textId))
        } else {
          selectedItems.value.push({ type: 'text', id: textId })
        }
      } else {
        selectedItems.value = [{ type: 'text', id: textId }]
      }
      syncSelectedArraysFromItems()
    }

    function handleTextMouseDown(event, textElement) {
      if (event.button === 2) return // Ignore right-click
      
      draggedText.value = textElement
      const canvasRect = canvas.value.getBoundingClientRect()
      const mouseX = (event.clientX - canvasRect.left) / zoom.value
      const mouseY = (event.clientY - canvasRect.top) / zoom.value
      
      dragOffset.value = {
        x: textElement.x - mouseX,
        y: textElement.y - mouseY,
      }

      // Add global mouse event listeners for text dragging
      document.addEventListener('mousemove', handleGlobalMouseMove)
      document.addEventListener('mouseup', handleGlobalMouseUp)
      
      event.preventDefault()
    }

    function handleTextResizeMouseDown(event, textElement) {
      event.stopPropagation()
      resizingText.value = textElement
      textInitialSize.value = {
        width: textElement.width,
        height: textElement.height,
        fontSize: textElement.fontSize
      }
      
      // Add global mouse event listeners for text resizing
      document.addEventListener('mousemove', handleGlobalMouseMove)
      document.addEventListener('mouseup', handleGlobalMouseUp)
      
      event.preventDefault()
    }

    async function updateText(textElement) {
      // Save to localStorage since we don't have backend support yet
      saveTextElementsToLocalStorage()
      console.log('Text updated:', textElement)
    }

    function saveTextElementsToLocalStorage() {
      const storageKey = `whiteboard_${whiteboardId.value}_texts`
      localStorage.setItem(storageKey, JSON.stringify(textElements.value))
    }

    function loadTextElementsFromLocalStorage() {
      const storageKey = `whiteboard_${whiteboardId.value}_texts`
      const stored = localStorage.getItem(storageKey)
      if (stored) {
        try {
          const loaded = JSON.parse(stored)
          // Ensure all text elements have width and height
          textElements.value = loaded.map(text => ({
            ...text,
            width: text.width || 200,
            height: text.height || 100,
            fontSize: text.fontSize || 16
          }))
        } catch (error) {
          console.error('Error loading text elements from localStorage:', error)
        }
      }
    }

    function toggleTextColorPicker(textId) {
      if (textColorPickerVisible.value === textId) {
        textColorPickerVisible.value = null
      } else {
        textColorPickerVisible.value = textId
      }
    }

    function confirmDeleteText(textId) {
      showDeleteModal(
        'Delete Text',
        'Are you sure you want to delete this text element?',
        async () => {
          deleteText(textId)
        }
      )
    }

    function deleteText(textId) {
      textElements.value = textElements.value.filter(t => t.id !== textId)
      selectedTexts.value = selectedTexts.value.filter(id => id !== textId)
      saveTextElementsToLocalStorage()
    }

    function handleBackgroundColorUpdate(color) {
      whiteboardBackgroundColor.value = color
    }

    function selectNote(noteId, event) {
      if (event.ctrlKey || event.metaKey) {
        const exists = selectedItems.value.find(i => i.type === 'note' && i.id === noteId)
        if (exists) {
          selectedItems.value = selectedItems.value.filter(i => !(i.type === 'note' && i.id === noteId))
        } else {
          selectedItems.value.push({ type: 'note', id: noteId })
        }
      } else {
        selectedItems.value = [{ type: 'note', id: noteId }]
      }
      syncSelectedArraysFromItems()
    }

    function handleNoteMouseDown(event, note) {
      if (event.button === 1) return // Ignore middle mouse button

      draggedNote.value = note
      
      // Get the actual bounding box of the transformed canvas
      const canvasRect = canvas.value.getBoundingClientRect()
      
      // Calculate the offset relative to the note's position in canvas coordinates
      const mouseX = (event.clientX - canvasRect.left) / zoom.value
      const mouseY = (event.clientY - canvasRect.top) / zoom.value
      
      dragOffset.value = {
        x: mouseX - note.x,
        y: mouseY - note.y,
      }

      // Note: Don't call selectNote here - it's handled by @click event
      // This prevents double-selection when Ctrl+clicking

      // Add global mouse event listeners to handle dragging outside the element
      document.addEventListener('mousemove', handleGlobalMouseMove)
      document.addEventListener('mouseup', handleGlobalMouseUp)
      
      event.preventDefault()
    }

    function handleGlobalMouseMove(event) {
      if (draggedNote.value) {
        // Use the existing canvas mouse move logic
        handleCanvasMouseMove(event)
      }
    }

    function handleGlobalMouseUp(event) {
      if (draggedNote.value || draggedText.value) {
        // Use the existing canvas mouse up logic
        handleCanvasMouseUp()
      }
      
      // Remove global listeners
      document.removeEventListener('mousemove', handleGlobalMouseMove)
      document.removeEventListener('mouseup', handleGlobalMouseUp)
    }

    function handleResizeMouseDown(event, note) {
      resizingNote.value = note
      event.stopPropagation()
    }

    function handleCanvasMouseDown(event) {
      // Don't handle if clicking on toolbar or buttons (should be stopped by @mousedown.stop but double-check)
      if (event.target.closest('.toolbar') || event.target.tagName === 'BUTTON') {
        return
      }
      
      // Check if clicking on a drawing path (not just the SVG background)
      const isClickingPath = event.target.tagName === 'path'
      
      if (event.button === 1) {
        // Middle mouse button - pan
        isPanning.value = true
        panStartX.value = event.clientX - panX.value
        panStartY.value = (event.clientY - 60) - panY.value  // Subtract toolbar height
      } else if (event.button === 0 && !isClickingPath && !draggedNote.value && !resizingNote.value && !draggedText.value) {
        // Clear selection when clicking on empty canvas (not on a path)
        // Don't clear if in draw mode - let the drawing happen
        if (!isDrawMode.value) {
          selectedNotes.value = []
          selectedTexts.value = []
          selectedItems.value = []
          selectedDrawing.value = null
          editingNote.value = null
          editingText.value = null
        }
      }
    }

    function handleCanvasMouseMove(event) {
      if (isPanning.value) {
        panX.value = event.clientX - panStartX.value
        panY.value = (event.clientY - 60) - panStartY.value  // Subtract toolbar height
      } else if (draggedNote.value) {
        const canvasRect = canvas.value.getBoundingClientRect()
        const newX = (event.clientX - canvasRect.left) / zoom.value - dragOffset.value.x
        const newY = (event.clientY - canvasRect.top) / zoom.value - dragOffset.value.y
        // Determine group selection (notes + texts)
        const selectedNoteIds = selectedItems.value.filter(i => i.type === 'note').map(i => i.id)
        const selectedTextIds = selectedItems.value.filter(i => i.type === 'text').map(i => i.id)

        if (selectedNoteIds.length > 1 && selectedNoteIds.includes(draggedNote.value.id)) {
          // Group drag: move selected notes and texts together
          const deltaX = newX - draggedNote.value.x
          const deltaY = newY - draggedNote.value.y

          for (const noteId of selectedNoteIds) {
            const note = stickyNotes.value.find((n) => n.id === noteId)
            if (note) {
              note.x = note.x + deltaX
              note.y = note.y + deltaY
            }
          }

          for (const textId of selectedTextIds) {
            const text = textElements.value.find(t => t.id === textId)
            if (text) {
              text.x = text.x + deltaX
              text.y = text.y + deltaY
            }
          }
        } else {
          // Single note drag without constraints
          draggedNote.value.x = newX
          draggedNote.value.y = newY
        }
      } else if (draggedText.value) {
        const canvasRect = canvas.value.getBoundingClientRect()
        const newX = (event.clientX - canvasRect.left) / zoom.value + dragOffset.value.x
        const newY = (event.clientY - canvasRect.top) / zoom.value + dragOffset.value.y
        
        const constrainedPos = constrainToWhiteboard(newX, newY, 100, 30)

        // Determine if group drag for texts (and move notes alongside)
        const selectedTextIds = selectedItems.value.filter(i => i.type === 'text').map(i => i.id)
        const selectedNoteIds = selectedItems.value.filter(i => i.type === 'note').map(i => i.id)

        if (selectedTextIds.length > 1 && selectedTextIds.includes(draggedText.value.id)) {
          const deltaX = constrainedPos.x - draggedText.value.x
          const deltaY = constrainedPos.y - draggedText.value.y

          // Move all selected texts
          for (const textId of selectedTextIds) {
            const text = textElements.value.find(t => t.id === textId)
            if (text) {
              text.x = text.x + deltaX
              text.y = text.y + deltaY
            }
          }

          // Also move selected notes so mixed selections move together
          for (const noteId of selectedNoteIds) {
            const note = stickyNotes.value.find((n) => n.id === noteId)
            if (note) {
              note.x = note.x + deltaX
              note.y = note.y + deltaY
            }
          }
        } else {
          draggedText.value.x = constrainedPos.x
          draggedText.value.y = constrainedPos.y
        }
      } else if (resizingText.value) {
        const canvasRect = canvas.value.getBoundingClientRect()
        const x = (event.clientX - canvasRect.left) / zoom.value
        const y = (event.clientY - canvasRect.top) / zoom.value

        const newWidth = Math.max(100, x - resizingText.value.x)
        const newHeight = Math.max(50, y - resizingText.value.y)
        
        // Scale font size proportionally based on width change
        const widthRatio = newWidth / textInitialSize.value.width
        const newFontSize = Math.max(8, Math.min(200, textInitialSize.value.fontSize * widthRatio))
        
        resizingText.value.width = newWidth
        resizingText.value.height = newHeight
        resizingText.value.fontSize = Math.round(newFontSize)
      } else if (resizingNote.value) {
        const canvasRect = canvas.value.getBoundingClientRect()
        const x = (event.clientX - canvasRect.left) / zoom.value
        const y = (event.clientY - canvasRect.top) / zoom.value

        resizingNote.value.width = Math.max(100, x - resizingNote.value.x)
        resizingNote.value.height = Math.max(100, y - resizingNote.value.y)
      }
      // Drawing is now handled by SVG event handlers
    }

    async function handleCanvasMouseUp() {
      if (draggedNote.value) {
        const draggedNoteId = draggedNote.value.id // Save ID before potential null
        await updateNote(draggedNote.value)
        // If we moved a group, update all selected notes and texts
        if (selectedItems.value.length > 1) {
          const noteIds = selectedItems.value.filter(i => i.type === 'note').map(i => i.id)
          const textIds = selectedItems.value.filter(i => i.type === 'text').map(i => i.id)

          for (const noteId of noteIds) {
            const note = stickyNotes.value.find((n) => n.id === noteId)
            if (note && note.id !== draggedNoteId) {
              await updateNote(note)
            }
          }

          for (const textId of textIds) {
            const text = textElements.value.find(t => t.id === textId)
            if (text) {
              await updateText(text)
            }
          }
        }
        draggedNote.value = null
      }

      if (draggedText.value) {
        const draggedTextId = draggedText.value.id // Save ID before potential null
        await updateText(draggedText.value)
        // If group drag, update all selected texts and notes
        if (selectedItems.value.length > 1) {
          const textIds = selectedItems.value.filter(i => i.type === 'text').map(i => i.id)
          const noteIds = selectedItems.value.filter(i => i.type === 'note').map(i => i.id)

          for (const textId of textIds) {
            const text = textElements.value.find(t => t.id === textId)
            if (text && text.id !== draggedTextId) {
              await updateText(text)
            }
          }

          for (const noteId of noteIds) {
            const note = stickyNotes.value.find((n) => n.id === noteId)
            if (note) {
              await updateNote(note)
            }
          }
        }
        draggedText.value = null
      }

      if (resizingText.value) {
        await updateText(resizingText.value)
        resizingText.value = null
      }

      if (resizingNote.value) {
        await updateNote(resizingNote.value)
        resizingNote.value = null
      }

      // Drawing save is now handled by SVG mouseup handler
      isPanning.value = false
    }

    function handleWheel(event) {
      event.preventDefault()
      
      const delta = event.deltaY > 0 ? 0.9 : 1.1
      
      // Dynamic zoom limits: min to fit whiteboard exactly, max 8x
      const maxZoom = 8.0
      
      // Get canvas bounding rect
      const canvasRect = canvas.value.getBoundingClientRect()
      
      // Get mouse position relative to canvas
      const mouseX = event.clientX - canvasRect.left
      const mouseY = event.clientY - canvasRect.top
      
      // Calculate canvas coordinates at mouse position (before zoom)
      const canvasX = mouseX / zoom.value
      const canvasY = mouseY / zoom.value
      
      // Apply zoom
      const newZoom = zoom.value * delta
      zoom.value = Math.max(minZoom.value, Math.min(maxZoom, newZoom))
      
      // Calculate new mouse position in canvas after zoom
      const newMouseX = canvasX * zoom.value
      const newMouseY = canvasY * zoom.value
      
      // Adjust pan to keep the canvas point under the mouse
      // The difference between old and new mouse positions tells us how much to adjust pan
      const deltaX = mouseX - newMouseX
      const deltaY = mouseY - newMouseY
      
      panX.value += deltaX
      panY.value += deltaY
    }

    function handleRightClick(event) {
      // Get the actual bounding box of the transformed canvas
      const canvasRect = canvas.value.getBoundingClientRect()
      
      // Calculate canvas coordinates from the bounding rect
      const canvasX = (event.clientX - canvasRect.left) / zoom.value
      const canvasY = (event.clientY - canvasRect.top) / zoom.value
      
      console.log('Right click:', {
        clientX: event.clientX,
        clientY: event.clientY,
        canvasRectLeft: canvasRect.left,
        canvasRectTop: canvasRect.top,
        panX: panX.value,
        panY: panY.value,
        zoom: zoom.value,
        canvasX,
        canvasY,
        // Verify: if we place a note at canvasX, canvasY, where will it appear?
        verifyScreenX: canvasRect.left + canvasX * zoom.value,
        verifyScreenY: canvasRect.top + canvasY * zoom.value
      })
      
      // Calculate scale for the context menu
      const menuScale = Math.max(0.7, Math.min(1.5, zoom.value))
      
      contextMenu.value = {
        visible: true,
        screenX: event.clientX, // Screen coordinates for menu positioning
        screenY: event.clientY,
        canvasX: canvasX,       // Canvas coordinates for item placement
        canvasY: canvasY,
        scale: menuScale,       // Scale factor for the menu
      }
      
      event.preventDefault()
      event.stopPropagation()
    }

    function closeContextMenu() {
      contextMenu.value.visible = false
    }

    function toggleDrawMode() {
      isDrawMode.value = !isDrawMode.value
    }

    function selectDrawing(drawingId, event) {
      if (!isDrawMode.value) {
        const already = selectedItems.value.find(i => i.type === 'drawing' && i.id === drawingId)
        if (event?.ctrlKey || event?.metaKey) {
          if (already) {
            selectedItems.value = selectedItems.value.filter(i => !(i.type === 'drawing' && i.id === drawingId))
          } else {
            selectedItems.value.push({ type: 'drawing', id: drawingId })
          }
        } else {
          if (already && selectedItems.value.length === 1) {
            selectedItems.value = []
          } else {
            selectedItems.value = [{ type: 'drawing', id: drawingId }]
          }
        }
        syncSelectedArraysFromItems()
      }
    }

    function confirmDeleteDrawing() {
      if (selectedDrawing.value) {
        showDeleteModal(
          'Delete Drawing',
          'Are you sure you want to delete the selected drawing?',
          async () => {
            await deleteSelectedDrawing()
          }
        )
      }
    }

    async function deleteSelectedDrawing() {
      if (selectedDrawing.value) {
        try {
          await api.deleteDrawing(selectedDrawing.value)
          drawings.value = drawings.value.filter(d => d.id !== selectedDrawing.value)
          selectedDrawing.value = null
        } catch (error) {
          console.error('Error deleting drawing:', error)
        }
      }
    }

    function setupWebSocket() {
      const wsUrl = `ws://localhost:8000/ws/whiteboard/${whiteboardId.value}/`
      ws = new WebSocket(wsUrl)

      ws.onmessage = (event) => {
        const data = JSON.parse(event.data)
        handleWebSocketMessage(data)
      }

      ws.onerror = (error) => {
        console.error('WebSocket error:', error)
      }

      ws.onclose = () => {
        console.log('WebSocket closed, reconnecting...')
        setTimeout(setupWebSocket, 3000)
      }
    }

    function handleWebSocketMessage(data) {
      if (data.type === 'note_added') {
        const exists = stickyNotes.value.find((n) => n.id === data.note.id)
        if (!exists) {
          stickyNotes.value.push(data.note)
        }
      } else if (data.type === 'note_updated') {
        const index = stickyNotes.value.findIndex((n) => n.id === data.note.id)
        if (index !== -1) {
          stickyNotes.value[index] = data.note
        }
      } else if (data.type === 'note_deleted') {
        stickyNotes.value = stickyNotes.value.filter((n) => n.id !== data.noteId)
      } else if (data.type === 'drawing_added') {
        const exists = drawings.value.find((d) => d.id === data.drawing.id)
        if (!exists) {
          drawings.value.push(data.drawing)
        }
      }
    }

    function broadcastUpdate(data) {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify(data))
      }
    }

    // Generate path data for different shapes
    function generateShapePath(start, end, shapeType) {
      if (!start || !end) return []
      
      const width = end.x - start.x
      const height = end.y - start.y
      
      switch (shapeType) {
        case 'rectangle':
          return [
            { x: start.x, y: start.y },
            { x: end.x, y: start.y },
            { x: end.x, y: end.y },
            { x: start.x, y: end.y },
            { x: start.x, y: start.y }
          ]
        
        case 'circle':
          // Generate circle using multiple points
          const centerX = start.x + width / 2
          const centerY = start.y + height / 2
          const radiusX = Math.abs(width / 2)
          const radiusY = Math.abs(height / 2)
          const points = []
          const segments = 40
          for (let i = 0; i <= segments; i++) {
            const angle = (i / segments) * Math.PI * 2
            points.push({
              x: centerX + radiusX * Math.cos(angle),
              y: centerY + radiusY * Math.sin(angle)
            })
          }
          return points
        
        case 'triangle':
          return [
            { x: start.x + width / 2, y: start.y }, // Top
            { x: end.x, y: end.y },                  // Bottom right
            { x: start.x, y: end.y },                // Bottom left
            { x: start.x + width / 2, y: start.y }  // Close
          ]
        
        case 'arrow':
          // Arrow: line with arrowhead
          const arrowHeadLength = 20
          const angle = Math.atan2(height, width)
          const arrowAngle = Math.PI / 6 // 30 degrees
          
          return [
            { x: start.x, y: start.y },
            { x: end.x, y: end.y },
            // Arrowhead
            { x: end.x - arrowHeadLength * Math.cos(angle - arrowAngle), 
              y: end.y - arrowHeadLength * Math.sin(angle - arrowAngle) },
            { x: end.x, y: end.y },
            { x: end.x - arrowHeadLength * Math.cos(angle + arrowAngle), 
              y: end.y - arrowHeadLength * Math.sin(angle + arrowAngle) }
          ]
        
        case 'line':
          return [
            { x: start.x, y: start.y },
            { x: end.x, y: end.y }
          ]
        
        default:
          return []
      }
    }

    function handleSvgMouseDown(event) {
      console.log('SVG MouseDown:', {
        isDrawMode: isDrawMode.value,
        button: event.button,
        clientX: event.clientX,
        clientY: event.clientY,
        panX: panX.value,
        panY: panY.value,
        zoom: zoom.value,
        target: event.target.tagName
      })
      
      if (isDrawMode.value && event.button === 0) {
        // Only handle drawing in draw mode with left click
        isDrawing.value = true
        // Convert screen coordinates to canvas coordinates
        const x = (event.clientX - panX.value) / zoom.value
        const y = (event.clientY - 60 - panY.value) / zoom.value  // Subtract toolbar height
        
        console.log('Starting draw at canvas coords:', { x, y })
        
        if (selectedShape.value === 'freehand') {
          currentPath.value = [{ x, y }]
        } else {
          // For shapes, store the start point
          shapeStartPoint.value = { x, y }
          currentPath.value = []
        }
        event.stopPropagation()
      }
      // For other cases (not draw mode, or non-left-click), let event bubble to container
    }

    function handleSvgMouseMove(event) {
      if (isDrawing.value && isDrawMode.value) {
        // Only handle drawing movement in draw mode
        const x = (event.clientX - panX.value) / zoom.value
        const y = (event.clientY - 60 - panY.value) / zoom.value  // Subtract toolbar height
        
        if (selectedShape.value === 'freehand') {
          if (currentPath.value.length % 10 === 0) {  // Log every 10th point to avoid spam
            console.log('Drawing at:', { x, y, pathLength: currentPath.value.length })
          }
          currentPath.value.push({ x, y })
        } else {
          // For shapes, update preview by recreating path from start to current point
          currentPath.value = generateShapePath(shapeStartPoint.value, { x, y }, selectedShape.value)
        }
        event.stopPropagation()
      }
      // For other cases, let event bubble to container for pan/drag handling
    }

    async function handleSvgMouseUp(event) {
      if (isDrawing.value && currentPath.value.length > 1) {
        try {
          const pathData = currentPathData.value
          const response = await api.createDrawing({
            whiteboard: whiteboardId.value,
            path_data: pathData,
            color: selectedColor.value,
            stroke_width: 2,
          })
          drawings.value.push(response.data)
          broadcastUpdate({ type: 'drawing_added', drawing: response.data })
        } catch (error) {
          console.error('Error saving drawing:', error)
        }
        currentPath.value = []
        shapeStartPoint.value = null
        isDrawing.value = false
        event.stopPropagation()
      }
      // For other cases, let event bubble to container
    }

    function updateWhiteboardDimensions() {
      // Keep large fixed dimensions for infinite whiteboard feel
      WHITEBOARD_WIDTH.value = 20000
      WHITEBOARD_HEIGHT.value = 15000
      
      // Initialize view to show existing content or center if no content
      if (canvas.value && zoom.value === 1 && panX.value === 0 && panY.value === 0) {
        const canvasRect = canvas.value.getBoundingClientRect()
        
        if (stickyNotes.value.length > 0) {
          // Calculate the center of existing notes
          const avgX = stickyNotes.value.reduce((sum, note) => sum + note.x, 0) / stickyNotes.value.length
          const avgY = stickyNotes.value.reduce((sum, note) => sum + note.y, 0) / stickyNotes.value.length
          
          // Pan to center the existing content
          panX.value = canvasRect.width / 2 - avgX * zoom.value
          panY.value = canvasRect.height / 2 - avgY * zoom.value
        } else {
          // No content, center the coordinate system
          panX.value = canvasRect.width / 2
          panY.value = canvasRect.height / 2
        }
        
        zoom.value = 1
      }
    }

    function handleKeyDown(event) {
      // Don't trigger delete if user is typing in a textarea or input
      if (event.target.tagName === 'TEXTAREA' || event.target.tagName === 'INPUT') {
        return
      }

      // Handle Delete or Backspace key
      if (event.key === 'Delete' || event.key === 'Backspace') {
        event.preventDefault() // Prevent browser back navigation on Backspace

        if (selectedItems.value.length > 0) {
          const count = selectedItems.value.length
          showDeleteModal(
            'Delete Selected Items',
            `Are you sure you want to delete ${count} selected item${count > 1 ? 's' : ''}?`,
            async () => {
              await deleteSelectedGroup()
            }
          )
        }
        // Backward-compatible: fallback to single-type selections (unlikely after sync)
        else if (selectedNotes.value.length > 0) {
          const count = selectedNotes.value.length
          showDeleteModal(
            'Delete Notes',
            `Are you sure you want to delete ${count} selected note${count > 1 ? 's' : ''}?`,
            async () => {
              await deleteSelected()
            }
          )
        } else if (selectedTexts.value.length > 0) {
          const count = selectedTexts.value.length
          showDeleteModal(
            'Delete Text Elements',
            `Are you sure you want to delete ${count} selected text element${count > 1 ? 's' : ''}?`,
            async () => {
              selectedTexts.value.forEach(textId => deleteText(textId))
              selectedTexts.value = []
            }
          )
        } else if (selectedDrawing.value) {
          showDeleteModal(
            'Delete Drawing',
            'Are you sure you want to delete the selected drawing?',
            async () => {
              await deleteSelectedDrawing()
            }
          )
        }
      }
    }

    onMounted(() => {
      loadWhiteboard()
      loadViewSettings()
      loadTextElementsFromLocalStorage()
      loadCustomColors()
      loadStandardColorNicknames()
      setupWebSocket()
      
      // Update dimensions after component is mounted
      setTimeout(updateWhiteboardDimensions, 100)
      
      // Listen for window resize
      window.addEventListener('resize', updateWhiteboardDimensions)
      
      // Listen for keyboard events
      document.addEventListener('keydown', handleKeyDown)
      
      document.addEventListener('click', () => {
        contextMenu.value.visible = false
      })
      
      // Handle paste events for images
      document.addEventListener('paste', async (event) => {
        const items = event.clipboardData?.items
        if (!items) return
        
        for (const item of items) {
          if (item.type.startsWith('image/')) {
            const file = item.getAsFile()
            if (file && selectedNotes.value.length === 1) {
              const note = stickyNotes.value.find(n => n.id === selectedNotes.value[0])
              if (note) {
                const fakeEvent = { target: { files: [file], value: '' } }
                await handleImageUpload(fakeEvent, note)
              }
            }
          }
        }
      })
    })

    // Watch for zoom and pan changes to save view settings
    watch([zoom, panX, panY], () => {
      saveViewSettings()
    })

    onUnmounted(() => {
      // Clear any pending save timeout
      if (saveViewSettingsTimeout) {
        clearTimeout(saveViewSettingsTimeout)
      }
      
      window.removeEventListener('resize', updateWhiteboardDimensions)
      document.removeEventListener('keydown', handleKeyDown)
      if (ws) {
        ws.close()
      }
    })

    return {
      canvas,
      canvasStyle,
      svgStyle,
      panX,
      panY,
      zoom,
      whiteboardId,
      whiteboardBackgroundColor,
      handleBackgroundColorUpdate,
      stickyNotes,
      selectedNotes,
  selectedItems,
      selectedColor,
      isDrawMode,
      selectedShape,
      drawings,
      currentPath,
      currentPathData,
      contextMenu,
      getNoteStyle,
      getNoteColor,
      addStickyNote,
      addStickyNoteAt,
      addLinkNote,
      updateNote,
      deleteNote,
  deleteSelected,
  deleteSelectedGroup,
      selectNote,
      handleNoteMouseDown,
      handleResizeMouseDown,
      handleCanvasMouseDown,
      handleCanvasMouseMove,
      handleCanvasMouseUp,
      handleSvgMouseDown,
      handleSvgMouseMove,
      handleSvgMouseUp,
      handleWheel,
      handleRightClick,
      closeContextMenu,
      toggleDrawMode,
      selectDrawing,
      selectedDrawing,
  confirmDeleteSelectedGroup,
      confirmDeleteDrawing,
      deleteSelectedDrawing,
      // Color picker
      showColorPicker,
      availableColors,
      standardColors,
      customColors,
      toggleColorPicker,
      changeNoteColor,
      handleImageUpload,
      // Insert menu
      showInsertMenu,
      showEmojiPicker,
      selectedEmojiCategory,
      emojiCategories,
      currentCategoryEmojis,
      toggleInsertMenu,
      toggleEmojiPicker,
      handleInsertImage,
      insertCheckbox,
      insertEmoji,
      insertHorizontalLine,
      toggleCheckbox,
      handleNoteTextClick,
      // Image carousel
      currentImageIndex,
      getCurrentImage,
      nextImage,
      prevImage,
      deleteCurrentImage,
      // Delete confirmation modal
      deleteModal,
      confirmDeleteNote,
      cancelDelete,
      confirmDelete,
      // Text elements
      textElements,
      selectedTexts,
      textColorPickerVisible,
      addTextAt,
      getTextStyle,
      selectText,
      handleTextMouseDown,
      handleTextResizeMouseDown,
      updateText,
      toggleTextColorPicker,
      confirmDeleteText,
      deleteText,
      // Editing
      editingNote,
      editingText,
      startEditingNote,
      stopEditingNote,
      startEditingText,
      stopEditingText,
    }
  },
}
</script>

<style scoped>
.whiteboard-container {
  width: 100vw;
  height: 100vh;
  display: flex;
  flex-direction: column;
  overflow: visible;
  background: white;
  margin: 0;
  padding: 0;
  position: fixed;
  top: 0;
  left: 0;
  cursor: default;
}

.toolbar {
  background: #333;
  padding: 10px 20px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  width: 100%;
  z-index: 1002;
  position: relative;
  flex-shrink: 0;
  pointer-events: auto;
}

.toolbar-left {
  display: flex;
  align-items: center;
  gap: 10px;
  flex: 1;
}

.toolbar-brand {
  display: flex;
  align-items: center;
  gap: 10px;
  transition: all 0.3s ease;
}

.toolbar-brand:hover {
  transform: translateY(-2px);
}

.brand-icon {
  font-size: 32px;
  animation: rotate-tilt 3s ease-in-out infinite;
}

@keyframes rotate-tilt {
  0%, 100% {
    transform: rotate(0deg);
  }
  25% {
    transform: rotate(-10deg);
  }
  75% {
    transform: rotate(10deg);
  }
}

.brand-text {
  font-size: 28px;
  font-weight: 700;
  color: white;
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
  letter-spacing: 1px;
  font-family: 'Comic Sans MS', 'Marker Felt', cursive, sans-serif;
}

.canvas-area {
  flex: 1;
  position: relative;
  overflow: visible;
  cursor: default;
  min-height: 0;
}

.canvas-area:active {
  cursor: grabbing;
}

.btn {
  padding: 8px 16px;
  background: #4caf50;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

.btn:hover {
  background: #45a049;
}

.btn.active {
  background: #ff9800;
}

.btn-danger {
  background: #f44336;
}

.btn-danger:hover {
  background: #da190b;
}

.color-select {
  padding: 8px;
  border-radius: 4px;
  border: 1px solid #ccc;
}

.hint-text {
  color: #999;
  font-size: 13px;
  font-style: italic;
  margin-left: 10px;
}

.shape-toolbar {
  display: flex;
  gap: 5px;
  align-items: center;
  padding: 4px 8px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 4px;
}

.shape-btn {
  padding: 6px 12px;
  background: rgba(255, 255, 255, 0.2);
  color: white;
  border: 1px solid rgba(255, 255, 255, 0.3);
  border-radius: 4px;
  cursor: pointer;
  font-size: 18px;
  transition: all 0.2s;
  min-width: 40px;
}

.shape-btn:hover {
  background: rgba(255, 255, 255, 0.3);
  border-color: rgba(255, 255, 255, 0.5);
}

.shape-btn.active {
  background: #ff9800;
  border-color: #ff9800;
  box-shadow: 0 0 8px rgba(255, 152, 0, 0.5);
}

.drawing-layer {
  pointer-events: none;
}

.drawing-layer path {
  pointer-events: auto;
}

.drawing-layer .selected-drawing {
  stroke-width: 4 !important;
  filter: drop-shadow(0 0 4px rgba(0, 123, 255, 0.8));
}

.sticky-note {
  position: absolute;
  border-radius: 0 8px 6px 4px;
  box-shadow: 
    0 4px 8px rgba(0, 0, 0, 0.1),
    0 2px 4px rgba(0, 0, 0, 0.06),
    inset 0 1px 0 rgba(255, 255, 255, 0.4);
  display: flex;
  flex-direction: column;
  cursor: move;
  user-select: none;
  transition: all 0.2s ease;
  overflow: hidden;
  pointer-events: auto;
  z-index: 1002;
}

.sticky-note::before {
  content: '';
  position: absolute;
  top: 0;
  right: 0;
  width: 15px;
  height: 15px;
  background: linear-gradient(-45deg, transparent 6px, rgba(0,0,0,0.05) 6px, rgba(0,0,0,0.05) 8px, transparent 8px);
  border-radius: 0 8px 0 0;
}

.sticky-note::after {
  content: '';
  position: absolute;
  top: 2px;
  right: 2px;
  width: 8px;
  height: 8px;
  background: linear-gradient(-45deg, transparent 40%, rgba(0,0,0,0.1) 40%, rgba(0,0,0,0.1) 60%, transparent 60%);
  border-radius: 0 6px 0 0;
}

.sticky-note:hover {
  box-shadow: 
    0 6px 12px rgba(0, 0, 0, 0.15),
    0 3px 6px rgba(0, 0, 0, 0.1),
    inset 0 1px 0 rgba(255, 255, 255, 0.4);
  transform: translate(0, -1px) rotate(var(--rotation, 0deg)) !important;
}

.sticky-note.selected {
  box-shadow: 
    0 0 0 3px #2196f3,
    0 6px 12px rgba(0, 0, 0, 0.15),
    0 3px 6px rgba(0, 0, 0, 0.1),
    inset 0 1px 0 rgba(255, 255, 255, 0.4);
}

.note-header {
  padding: 4px 8px 2px 8px;
  border-radius: 0 8px 0 0;
  display: flex;
  justify-content: flex-end;
  background: rgba(0, 0, 0, 0.02);
  border-bottom: 1px solid rgba(0, 0, 0, 0.05);
}

.delete-btn {
  background: rgba(0, 0, 0, 0.15);
  border: none;
  color: rgba(0, 0, 0, 0.6);
  font-size: 16px;
  line-height: 1;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  cursor: pointer;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: center;
}

.delete-btn:hover {
  background: rgba(220, 53, 69, 0.8);
  color: white;
  transform: scale(1.1);
}

.note-content {
  flex: 1;
  padding: 8px 12px 12px 12px;
  display: flex;
  flex-direction: column;
  gap: 8px;
  background: inherit;
}

.image-carousel {
  position: relative;
  display: flex;
  align-items: center;
  gap: 4px;
  margin-bottom: 8px;
}

.image-container {
  position: relative;
  flex: 1;
  display: flex;
  justify-content: center;
  align-items: center;
}

.note-image {
  max-width: 100%;
  max-height: 150px;
  object-fit: contain;
  border-radius: 4px;
}

.carousel-btn {
  background: rgba(0, 0, 0, 0.5);
  border: none;
  color: white;
  font-size: 24px;
  width: 28px;
  height: 28px;
  border-radius: 50%;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
  padding: 0;
  line-height: 1;
  flex-shrink: 0;
}

.carousel-btn:hover {
  background: rgba(0, 0, 0, 0.7);
  transform: scale(1.1);
}

.delete-image-btn {
  position: absolute;
  top: 4px;
  right: 4px;
  background: rgba(220, 53, 69, 0.8);
  border: none;
  color: white;
  font-size: 16px;
  width: 24px;
  height: 24px;
  border-radius: 50%;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
  opacity: 0;
  z-index: 10;
  pointer-events: auto;
}

.image-container:hover .delete-image-btn {
  opacity: 1;
}

.delete-image-btn:hover {
  background: rgba(220, 53, 69, 1);
  transform: scale(1.1);
}

.image-counter {
  position: absolute;
  bottom: 4px;
  right: 4px;
  background: rgba(0, 0, 0, 0.6);
  color: white;
  font-size: 10px;
  padding: 2px 6px;
  border-radius: 10px;
  pointer-events: none;
}

.note-content textarea {
  flex: 1;
  border: none;
  resize: none;
  font-family: var(--note-font-family, 'Comic Sans MS', 'Marker Felt', cursive, sans-serif);
  font-size: var(--note-font-size, 14px);
  color: var(--note-font-color, #333);
  line-height: 1.4;
  outline: none;
  background: transparent;
  padding: 4px;
  cursor: default;
  user-select: none;
  pointer-events: none;
}

.note-content textarea.editable {
  cursor: text;
  user-select: text;
  pointer-events: auto;
}

.note-text-display {
  flex: 1;
  font-family: var(--note-font-family, 'Comic Sans MS', 'Marker Felt', cursive, sans-serif);
  font-size: var(--note-font-size, 14px);
  color: var(--note-font-color, #333);
  line-height: 1.4;
  padding: 4px;
  white-space: pre-wrap;
  word-wrap: break-word;
  cursor: default;
}

.note-checkbox {
  margin-right: 6px;
  cursor: pointer;
  width: 16px;
  height: 16px;
  vertical-align: middle;
}

.link-input {
  width: 100%;
  padding: 4px;
  border: 1px solid #ddd;
  border-radius: 3px;
  font-size: 12px;
}

.resize-handle {
  position: absolute;
  bottom: 2px;
  right: 2px;
  width: 12px;
  height: 12px;
  background: linear-gradient(135deg, transparent 50%, rgba(0,0,0,0.1) 50%);
  cursor: nwse-resize;
  border-radius: 0 0 4px 0;
  opacity: 0.6;
  transition: opacity 0.2s ease;
}

.sticky-note:hover .resize-handle {
  opacity: 1;
}

.context-menu {
  position: fixed;
  background: white;
  border: 1px solid #ddd;
  border-radius: 6px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
  z-index: 10001;
  overflow: hidden;
  min-width: 150px;
  pointer-events: auto;
}

.context-menu div {
  padding: 12px 16px;
  cursor: pointer;
  color: #333;
  font-size: 14px;
  font-weight: 500;
  border-bottom: 1px solid #f5f5f5;
  transition: all 0.2s ease;
}

.context-menu div:last-child {
  border-bottom: none;
}

.context-menu div:hover {
  background: #007bff;
  color: white;
}

/* Color picker styles */
.color-btn {
  background: rgba(0, 0, 0, 0.1);
  border: none;
  font-size: 14px;
  width: 24px;
  height: 20px;
  border-radius: 3px;
  cursor: pointer;
  margin-right: 4px;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: center;
}

.color-btn:hover {
  background: rgba(0, 0, 0, 0.2);
}

.image-btn {
  background: rgba(0, 0, 0, 0.1);
  border: none;
  font-size: 14px;
  width: 24px;
  height: 20px;
  border-radius: 3px;
  cursor: pointer;
  margin-right: 4px;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: center;
}

.image-btn:hover {
  background: rgba(0, 0, 0, 0.2);
}

.color-picker {
  position: absolute;
  top: 32px;
  left: 8px;
  background: white;
  border: 1px solid #ddd;
  border-radius: 6px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
  z-index: 1000;
  padding: 8px;
}

.color-grid {
  display: grid;
  grid-template-columns: repeat(6, 1fr);
  gap: 6px;
}

.color-option {
  width: 32px;
  height: 32px;
  border: 2px solid transparent;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.color-option:hover {
  transform: scale(1.1);
  border-color: #666;
}

.color-option.active {
  border-color: #007bff;
  box-shadow: 0 0 0 1px #007bff;
}

/* Insert menu */
.insert-btn {
  background: none;
  border: none;
  color: rgba(0, 0, 0, 0.6);
  font-size: 14px;
  cursor: pointer;
  padding: 2px 6px;
  border-radius: 3px;
  transition: all 0.2s ease;
}

.insert-btn:hover {
  background: rgba(0, 0, 0, 0.1);
  transform: scale(1.1);
}

.insert-menu {
  position: absolute;
  top: 32px;
  left: 40px;
  background: white;
  border: 1px solid #ddd;
  border-radius: 6px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
  z-index: 1000;
  padding: 4px;
  min-width: 150px;
}

.insert-option {
  display: block;
  width: 100%;
  padding: 8px 12px;
  background: none;
  border: none;
  text-align: left;
  cursor: pointer;
  border-radius: 4px;
  transition: background 0.2s ease;
  font-size: 14px;
  color: #333;
}

.insert-option:hover {
  background: rgba(0, 123, 255, 0.1);
}

.emoji-picker {
  position: absolute;
  top: 32px;
  left: 40px;
  background: white;
  border: 1px solid #ddd;
  border-radius: 6px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
  z-index: 1001;
  padding: 8px;
  width: 320px;
}

.emoji-categories {
  display: flex;
  gap: 4px;
  margin-bottom: 8px;
  padding-bottom: 8px;
  border-bottom: 1px solid #e0e0e0;
}

.category-btn {
  background: none;
  border: 1px solid #ddd;
  padding: 6px 10px;
  font-size: 18px;
  cursor: pointer;
  border-radius: 4px;
  transition: all 0.2s ease;
  flex: 1;
  min-width: 0;
}

.category-btn:hover {
  background: rgba(0, 123, 255, 0.1);
  border-color: #007bff;
}

.category-btn.active {
  background: #007bff;
  border-color: #007bff;
  color: white;
}

.emoji-grid-scrollable {
  max-height: 240px;
  overflow-y: auto;
  overflow-x: hidden;
}

.emoji-grid {
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  gap: 4px;
}

.emoji-btn {
  background: none;
  border: 1px solid transparent;
  padding: 6px;
  font-size: 20px;
  cursor: pointer;
  border-radius: 4px;
  transition: all 0.2s ease;
}

.emoji-btn:hover {
  background: rgba(0, 123, 255, 0.1);
  border-color: #007bff;
  transform: scale(1.2);
}

/* Modal styles */
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 2000;
}

.modal {
  background: white;
  border-radius: 8px;
  padding: 24px;
  width: 90%;
  max-width: 400px;
}

.modal h3 {
  margin: 0 0 12px 0;
  color: #333;
}

.modal p {
  margin: 0 0 20px 0;
  color: #666;
}

.modal-actions {
  display: flex;
  gap: 10px;
  justify-content: flex-end;
}

.btn {
  padding: 8px 16px;
  border: 1px solid #ddd;
  border-radius: 4px;
  background: white;
  color: #333;
  cursor: pointer;
  font-size: 14px;
  transition: all 0.2s ease;
}

.btn:hover {
  background: #f8f9fa;
}

.btn-danger {
  background: #dc3545;
  color: white;
  border-color: #dc3545;
}

.btn-danger:hover {
  background: #c82333;
  border-color: #bd2130;
}

/* Text element styles */
.text-element {
  position: absolute;
  min-width: 100px;
  min-height: 30px;
  cursor: move;
  user-select: none;
  border-radius: 4px;
  padding: 4px;
  border: 1px solid transparent;
  transition: all 0.2s ease;
  pointer-events: auto;
  z-index: 1002;
}

.text-element:hover {
  border-color: #ddd;
  filter: brightness(1.05);
}

.text-element.selected {
  border-color: #007bff;
  box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
}

.text-input {
  border: none;
  outline: none;
  background: transparent;
  resize: none;
  width: 100%;
  height: 100%;
  min-height: 20px;
  font-family: var(--note-font-family, Arial, sans-serif);
  font-size: var(--text-font-size, 16px);
  color: var(--note-font-color, #333);
  line-height: 1.2;
  padding: 0;
  cursor: default;
  user-select: none;
  pointer-events: none;
}

.text-input.editable {
  cursor: text;
  user-select: text;
  pointer-events: auto;
}

.text-color-btn {
  position: absolute;
  top: -8px;
  left: -8px;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  border: none;
  background: #007bff;
  color: white;
  font-size: 12px;
  cursor: pointer;
  display: none;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
}

.text-element:hover .text-color-btn {
  display: flex;
}

.text-color-btn:hover {
  background: #0056b3;
  transform: scale(1.1);
}

.text-color-picker {
  position: absolute;
  top: -50px;
  left: 0;
  background: white;
  border: 1px solid #ddd;
  border-radius: 6px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
  padding: 8px;
  display: flex;
  gap: 8px;
  align-items: center;
  z-index: 1000;
}

.text-color-input {
  width: 40px;
  height: 30px;
  border: 1px solid #ddd;
  border-radius: 4px;
  cursor: pointer;
}

.text-color-value {
  font-family: 'Courier New', monospace;
  font-size: 12px;
  color: #333;
}

.text-delete-btn {
  position: absolute;
  top: -8px;
  right: -8px;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  border: none;
  background: #dc3545;
  color: white;
  font-size: 12px;
  cursor: pointer;
  display: none;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
}

.text-element:hover .text-delete-btn {
  display: flex;
}

.text-delete-btn:hover {
  background: #c82333;
  transform: scale(1.1);
}

.text-resize-handle {
  position: absolute;
  bottom: 0;
  right: 0;
  width: 16px;
  height: 16px;
  background: #007bff;
  cursor: nwse-resize;
  border-radius: 0 0 4px 0;
  opacity: 0.6;
  transition: opacity 0.2s ease;
}

.text-element:hover .text-resize-handle {
  opacity: 1;
}
</style>
